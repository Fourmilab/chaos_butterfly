
                    Fourmilab Lorenz Butterfly

                        Development Log


2022 September 26

Added Set variables for all Lorentz parameters: beta, rho, sigma, and
deltaT.  These may be either floats or rationals, and if the value is
omitted, resets the variable to the default.

Added Set variable for scale.

Added all new variables to the Status output.  Added running and
attached to Status, and show to whom we're attached if so.

Replaced the original Test/Quit command structure with a:
    Run on/off/time/async
command as in Double Pendulum.

Added the:
    Set path on/off/lines [ permanent/clear ]
mechanism from Double Pendulum.  I found that the same 12 line plotter
scripts we used in that object seem to keep up and avoid message loss
here.

Added a Set path width n command to set the width of paths, both
particle and line.  Note that particle width cannot be set below
0.3125 and line width will be snapped to the closest of the values
supported by the line plotters: 0.01, 0.015, 0.02, 0.025.  Thus, you'll
want to tune this setting based upon the kind of path you're going to
draw.

Installed the link message code to support scripts and menus.

Installed a "Script: Configuration" to test script execution.

2022 September 27

A great many things were messed up regarding drawing lines for trails.
First of all, the scripts for permanent and temporary line prims had
different tables for widths, resulting in absurdly fat lines when
permanent prims were selected.  The temporary prim script lacked the
code to set PRIM_TEMP_ON_REZ based upon its name, and hence required a
hard temporary setting in the prim definition, resulting in the
"peekaboo prim" problem when editing it.  Finally, the temporary prim's
script was from the Orbits literary output and lacked all comments.  As
fixed, the two scripts are now absolutely identical and determine their
permanence from their names.

Added the ability to plot critical points, depending upon the current
parameters, with:
    Set critical [ permanent ]
This draws axes gnomons at the critical points.  These are usually
temporary prims, but you can make them permanent by so specifying.
They will be cleared by Set path line clear.

On further reflection, changed the drawing of critical point gnomons
to use the colours of the viewer labeling of axes: X red, Y green, Z
blue.

Added "Set path colour <r,g,b>" to set the colour of both particle and
line paths.

Licensed a collection of nine butterfly textures from:
    https://www.shutterstock.com/image-vector/collection-multicolored-butterflies-vector-illustration-1912569607
These are EPS vector images which I converted into PNGs with
transparency using Gimp to import the EPS at 300 dpi, then cropped,
scaled, and added transparency.  I may see if I can find some natural
photos of real butterflies to add as well.

Added a "Set offset <x,y,z>" command to set the offset from the initial
position of the butterfly to where it begins flight.  This is usually
used to raise the flight display so it doesn't intersect the ground,
but you can set it however you wish.

There is a mystery when attached to an avatar.  If you perform a run,
then stop, and then run again, sometimes, but not always, the avatar
just remains stuck at the starting position.  Trace shows the
llMoveToTarget calls are being made to correct locations, the avatar is
physical, and that everything seems normal, but the avatar doesn't
move.  If you then use the viewer button to stop flying, suddenly the
avatar starts moving normally, but with the "falling" animation.  If
you then put the avatar back in flying mode, everything is fine again.
I have tried forcing a llStopMoveToTarget(), delays, etc., but nothing
so far has made any difference once you get in this stuck mode.  The
only way to escape seems to be the manual stop flying while you're
stuck.  I have no idea what is going on.

Added a "Set texture name" command which replaces the butterfly texture
with the named one in the inventory.  These texture names must be all
lower case and contain no spaces, since I don't want to bring in the
big and messy inventoryName function we use elsewhere.  If no name is
specified, textures in the inventory are listed.

2022 September 28

Installed an automatic scaling mechanism so that the hue range of
trails in polychrome mode accurately reflects the extreme excursion
based upon the current parameters.  Whenever a run is started or any
of the parameters change, updateScale() is called which performs
1000 iterations and records the maximum excursion from the closest
critical point by the trajectory.  This is stored in maxExcursion,
which is used to scale the hue in which the trail is drawn.

Changed the Run on command to start the simulation at a randomly
chosen point between 1/6 and 1/5 along a vector connecting critical
points 1 and 2.

Added the ability to texture with top and bottom butterfly images.
The "Set texture" command now looks for a companion image with the
specified name and "-bottom" appended.  If found, that image is placed
on the bottom of the butterfly prim.

Made a top and bottom set for "butterfly10" from the Wikimedia image of
Morpho menelaus, which is licensed under Creative Commons
Attribution-Share Alike 4.0 International license.
    https://en.wikipedia.org/wiki/File:Morpho_menelaus_huebneri_MHNT_Male.jpg

2022 September 29

After many hours of experimentation, I am getting a few glimmers of
enlightenent on why particle trails do not align with critical point
gnomons when we're attached to an avatar.  The key clue is that line
trails, which are placed based upon the transformed Lorenz co-ordinates
work just fine.  What's happening with particles is, in short, that
we're moving the avatar to follow the trajectory which causes it to
move its centre of mass (the hip bone) to the position we specify.
But the attachment is to another bone (usually the chest), and this
not only has an offset from the avatar position, that offset varies as
the avatar moves.  To correct for this offset, we would need to get the
real-time offset from the avatar position to the attachment position,
and I can't find any way to do this.

We may just have to live with this.  If you want trails that align with
the Set crit points whie attached, use Set path lines.  Otherwise, it's
going to be wonky.

Another infelicitous behaviour of particle trails is that since the
particle emitter in the butterfly is offset from the avatar's centre,
when the avatar turns, you will get a discontinuity in the trail.  The
only way to keep that from happening would be to make a two prim
butterfly in which there was a prim to be attached to the avatar centre
but transparent, to hold the particle emitter, and another, visible, to
actually do the work.  I find it difficult to justify all of this
complexity to remedy a minor cosmetic problem which I suspect few
people will ever encounter since most won't ever wear the butterfly as
an attachment in the first place.

Added a general lorenz2Region() function to transform Lorenz
co-ordinates to region co-ordinates rather than writing it out in three
places.  Added logic to the function to rotate by the rotation of the
object at the time the Run started, allowing control of the orientation
of the trails in region space.  Made the restoration of starting point
at Run off also restore the initial rotation rather than resetting to a
fixed value.  This applies also when attached to an avatar.  The path
flown in the sky will depend upon the initial rotation of the flying
avatar at the time of the "Run on".

Made a texture, top and bottom, of the Millennium Falcon from:
    https://www.the-millennium-falcon.com/2018/03/12/done/
It isn't just butterflies any more!

When you started in paths mode, you'd often get a particle trail from
the start point to the first computed point on the trajectory even
though the particle system was only enabled after the move to the start
of the trajectory.  This appears to be because we used
llSetLinkPrimitiveParamsFast() for the move and it was too fast--the
viewer enabled the particle system before it got the command to start
the move.  I added a 0.2 second llSleep() after the initial move before
enabling the particle system and that appears to have fixed it.

2022 September 30

Added a plotLine() function to assemble and send the request to a Line
plotter to draw a line in space and replaced all of the written-out
instances of this code with a call to the function.

If the user tried to "Set critical" before a Run was started, the
critical points would be drawn in the wrong place because the initial
position and rotation of the object had not been captured.  Trying to
obtain them in the Set critical command could mess things up when the
command was issued while running, so I simply added a test to reject
the command except when a simulation was running.

2022 October 1

To allow different levels of trace information, I added the ability
to "Set trace n" which sets it to the given value.  The "on" setting
corresponds to n = 1.

Completed the grand revision of the code to rationalise the orientation
of the model as it moves along its trajectory.  This is done in the
timer() event after we've computed the next point in the Lorenz
trajectory.  First, we form the vector from the previous point to the
new point, normalise it, and call it flight.  We define a vector look
which is the normalised direction from the new point to the closest of
the two critical points of the Lorenz system.  We then compute, using
our local flRotBetween(), the rotation vdir to align the local Z axis
of the model with the flight vector, which will, given the shape of our
model and its texture, make it fly along the path from the previous to
the current point.  This process, however, leaves the rotation around
this local Z axis as a free parameter, and it comes out essentially
arbitrary, which results in wild and apparently random (although, of
course, entirely deterministic) gyrations as the model moves along its
trajectory.

That won't do.  So, what we do is then proceed to rotate the model
around its local Z axis so that its top [defined by the side we've so
textured, which is llRot2Up(vdir)].  Next, we want to project the look
vector into the plane in which we're going to rotate the model to align
it, which is:
    lproj = look - ((look . up) * up)
Now, we need to compute the rotation about the Z axis to align the top
of the model with this projected vector, which is the arc cosine of
lproj dot left.  But, since this is a dot product, it only tells us the
angle between the two vectors, not the direction in which we need to
rotate to align them.  So next we compute the cross product of up and
lproj, which gives the normal of the direction of travel and projected
direction to the critical point, and then take the dot product of that
with the left vector.  The sign of this dot product indicates whether
the projection of the vectors are parallel or antiparallel, and hence
the direction we need to rotate to align them. Finally, we rotate vdir
by the computed rotation in the direction indicated by the sign, and
we're there: the model will point along the direction of travel with
its top aligned with a vector from its new position to the closest
critical point.

Now, wasn't that simple?  It's crazy to do, but it looks great and it
minimises the vertigo-inducing effects of an over the shoulder or
mouselook view when an avatar is riding the model.

Created a Git repository and made an initial commit of the current
state of development, including scripts, textures, notecards, and this
log.

2022 October 2

Made the first rough cut at a deployer, based upon the SAM Site
deployer for the Rocket, which simplifies placing multiple butterfiles
in a vicinity to create a cloud of non-interacting butterflies.  The
deployer places them and then they are subsequently controlled by chat
commands sent to their common channel, which is 1000 greater than the
default channel for the stand-alone model.  When rezzed by the
deployer, the model will respond to a special command sent by the
deployer which causes it to self-destruct with llDie() when the
deployer receives the "Remove" command.  This allows easy clean-up of
created models.

There are myriad features and tweaks that could, and doubtless will, be
added to the deployer and to the model to work better with it, but it's
basically working and allows evaluation of its behaviour in order to
decide where we want to take it.

The Set path command may be trying to do too many things to be
comprehensible to the user, no less to the humble programmer charged
with implementing it.  I fixed a bunch of bugs in it without, for the
moment, undertaking a redesign or splitting it into two or more
commands.  The Set path lines command now turns off generation of
particle paths, and the Set path lines command now clears existing
lines without affecting the generation of either line or particle
paths.

The "Run on" command caused butterflies to quit almost instantly
because it misinterpreted "on" as a run expiration time due to a bad
test when I changed it to use flIsDigit().  Fixed.

Added code to allow the Deployer to set the texture used by the
butterflies it creates.  It passes a texture number from the Deploy
command via the on_rez() start_param argument, where the number
corresponds to the numbers show by the "Set texture" command in the
butterfly model being deployed.  (The llRezObject() function can pass
only one 32-bit integer to the object being created.)  A texture number
of zero causes the butterfly to chose its texture based upon its
instance number from the deployer modulo the number of textures in its
inventory. In doing this, "-bottom" textures are ignored.

Added a test which restricts the magic command the Deployer sends to
butterflies to cause them to self-destruct to only responding if the
command was sent by the Deployer that created the butterfly.  This
prevents malicious sending of this command by others or butterflies
being destroyed by a different Deployer in the same region.

Added a "Set start min [ max ]" command to specify a range of
percentages of the distance between the critical points from which the
starting point will be chosen by the Run command.  If only one number
is given, that value will always be used.  You can specify negative
percentages and percentages greater than 100 if you wish points outside
the limits of the critical points.  Note that if you specify 0 or 100
exactly (the critical points), the butterfly will remain stuck there as
those are fixed points for the system.

To run sensitive dependence on initial conditions experiment:
    Rez two butterflies near one another.
    Edit the Configuration script in 1 and add:
        Channel 4001
    Edit the Configuration script in 2 and add:
        Channel 4002
    Edit objects and move 1 and 2 to the same position.
    /1963 boot
    /4001 set texture butterfly2
    /4002 set texture butterfly3
    # Start experiment run
    /4001 set start 20
    /4002 set start 20.000001
    /4002 channel 4001
    /4001 run on
    # When done
    /4001 run off
    /4001 boot
You can now run the experiment again, starting with setting the
"Set start" commands with whatever settings you want to try.

If you start from identical start points, after a while one of the
butterflies may get ahead of the other, but they will both continue to
follow the same trajectories.  The position discrepancy is because
each butterfly has its own update clock and lag in the Second Life
simulator causes them to drift apart over long periods of time even
though they are set to the same rate.  If the start points differ even
by a tiny amount, however, the paths will rapidly diverse and before
long the butterflies will be circling different critical points.

2022 October 3

Now that we properly align the local Z axis of the object with our
direction of travel at all times, I decided to see if using
PSYS_PART_RIBBON_MASK for the particle trail definition worked better.
It does: it's still a bit wonky, especially when we're moving quickly
or turning tight corners, but I think it's better, overall, than the
disconnected dots we had been using.  Getting it to display properly
requires increasing pathWidth to 0.75, which will cause Set path lines
to use the maximum width of 0.025.  Since I intended to make that the
default anyway, this is fine.

Added a Boot command to the Deployer for consistency with other
Fourmilab products.

Added logic in butterfly on_rez() to append ": n" to the object name
if we were rezzed by the deployer, where n is the deployer index of the
object.  If the name previously contained the suffix, it is deleted
before the new name is generated.

Added a List command to support the Deployer's List feature.  It simply
reports its position and Run status, counting on the viewer to report
its object name, which will contain the deployer index.  Getting this
through the access check and getting the output back to the deployer
owner is a spot of bother.  By default, tawk() would send the output
back to the deployer itself, which would ignore it.  I modified
processCommand to, if it detects the command was sent from the
Deployer, set whoDat to the owner of the deployer, directing the output
correctly. The usual access check on the ID who sent the command is
skipped if we were rezzed by a deployer and the command sender's ID is
that of our deployer.

Added a Status command to the Deployer.  People expect it, even though
it doesn't tell you much of interest.

Changed the Deployer's command channel to the production value of 1977.
This is the year modern commercial butterfly breeding began on Guernsey.



Notes and to-do:

    (Place particle emitter in link, and then position link at the
     co-ordinates that put it at avatar's centre point.  But this won't
     work as skeleton moves the attachment and link away from that.)

    * More than one run session with attached object.
    * Reset command to restore initial settings
    * Offset of crit points when wearing

    * Start parameter as % distance from critical points
    * Sensitive dependence example
    * LIST command for deployed butterflies
